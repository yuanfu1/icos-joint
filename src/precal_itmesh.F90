!=================================================================
!  This program and module contains the code that pre-calculates
!  geometric quantities that are required by the numerical model
!  that is based on icos-triangle meshe.  
!  
!  The program reads in the icosahedren grid information and 
!  calculates the gepmetric quantiites that are either based on 
!  spherical geometry or Euclidean geometry. In other words, 
!  the calculation is based on either a ideal spherical earth,
!  or its approximation, a polyhedron consisting of triangle
!  faces.
! 
!  Ning Wang, Aug. 2018, original version
!  
!==================================================================
!#define WRITE_OUTPUT
!>
!!===================================================================
!!  Third order accurate tangential derivative has to have 10 cells
!!  even though the normal derivative does not.
!!
!!  Thus, for now, we set NO_REP_10_PTS. It adds a 10th cell outside
!!  a pentagon. For example, for cell 1 edge 1 at G3, we add 514 as
!!  the 10th cell instead of repeating 513 as faked 10th cell. The
!!  cell number is based on Ning's cell generation.
!!
!!  Noted by Yuanfu Xie May 2019
!!===================================================================
#define SPH_GEO
#define EULER_ROT
#define NO_REP_10_PTS
#define WRITE_OUTPUT
#define NEW_STCL
#define SHARE_EDGE
!#define VRTX_HEXAGRAM
!#define DIAG
#define VRTX_LGHEXAGON

MODULE precal
USE precal_data
IMPLICIT NONE

!INTEGER, ALLOCATABLE :: num_tri(:)
INTEGER :: dbg_ipn, dbg_tri

CONTAINS
SUBROUTINE precal_itmesh(glvl, itmesh)
  ! data types to hold grid information needed for the model

  INTEGER :: glvl
  TYPE(ITmeshGeoQnty) :: itmesh
  INTEGER :: ipn, tri_num
  INTEGER :: side_len, nip, ntmp

  ! data type to hold triangle grid info created by TriMeshGen.F90
  TYPE TriangleCell
    INTEGER :: vertex(3)    ! icos grid point seqnum for each vertex
    INTEGER :: adjnb(3)     ! adjacent neighbors
  END TYPE TriangleCell
  TYPE(TriangleCell), ALLOCATABLE :: tmesh(:)

  ! variables for namelist
  CHARACTER(len=256) :: icos_tri_grid_file
#ifdef WRITE_OUTPUT
  CHARACTER(len=256) :: icos_tri_grid_pc_file
#endif
  CHARACTER(len=2) :: gls
  INTEGER :: ierr
  REAL*8 :: latlon1(2), latlon2(2), latlon3(2)
  REAL*8 :: ll(2,edge_stcl_sz+10), mp(2)
  REAL*8 :: xy_1_ssz(2,edge_stcl_sz+10), xy1_1_ssz(2,edge_stcl_sz+10), xy2_1_ssz(2,edge_stcl_sz+10)
  REAL*8 :: qp1(2), qp2(2), qp3(2), qp4(2), r1, r2, r3, r4
  REAL*8 :: xyz(3,3), t_vec(3,3), n_vec(3,3), cntr_xyz(3), cntr_ll(2) 
  REAL*8 :: x_axis(3), y_axis(3), t_vec2d(2), n_vec2d(2)
  REAL*8 :: edge(2,2)

  REAL*8, PARAMETER :: piov2 = acos(-1.0)/2.0   
  REAL*8, PARAMETER :: r2d = 180.0/acos(-1.0)   
  REAL*8, PARAMETER :: latdt = 0.0001

  ! temp variables
  INTEGER :: i, j, k, l, m, jp, s_idx, stcl_cndt, vrtx_stcl_sz
  INTEGER :: jp1, jm1, jp_p1, jp_m1, kp1, nb_sidx, nb_sidx_p1, nb_sidx_m1
  INTEGER :: stcl(edge_stcl_sz+10)
  INTEGER :: cndt_list(10), num_cndts

  INTEGER, PARAMETER :: subdiv(20) = 2
  REAL*8, PARAMETER :: earth_radius = 6371.220*1000.0
  REAL*8 :: side(3), s, a, b, c, tanEov4
  REAL :: p(2), p1(2), p2(2)
  INTEGER :: itmp, v1, v2, adjnb(3), nb_idx
  INTEGER :: ncell_vrtx1, ncell_vrtx2

  INTEGER, PARAMETER :: stcl_sz = 13
  INTEGER, PARAMETER :: ndbp = 1
  INTEGER, PARAMETER :: i_debug = 1

  INTEGER :: ij_debug(2,ndbp)
  INTEGER :: tri

  REAL*8 :: lonmin,lonmax
  
  ! Yuanfu added some variables for tangential derivatives and debugging:

  LOGICAL :: righthand
  LOGICAL :: dbg_prt
  REAL*8 :: earth_area
  INTEGER :: fe

  ij_debug(1,1) = 1; ij_debug(2,1) = 1
  !ij_debug(1,2) = 3; ij_debug(2,2) = 2
  !ij_debug(1,3) = 3; ij_debug(2,3) = 3

! calculate number of icosahedral grid points (nip) and triangle mesh points (ntmp) 
  side_len = 1
  DO i = 1, glvl
   side_len = side_len*subdiv(i) 
  ENDDO
  nip = 10*(side_len*side_len)+2
  ntmp = 2*(nip-2)

  PRINT*, nip, ntmp
! allocate memory for various arrays
  ALLOCATE(tmesh(ntmp))

! read in triangle grid file generated by TriMeshGen.F90
  WRITE (gls, "(I2.2)") glvl
  icos_tri_grid_file = "icos_tri_grid_g" // gls // ".dat"
  PRINT*, 'Read in grid info file: ', trim(icos_tri_grid_file)
  OPEN(10,file=trim(icos_tri_grid_file),form='unformatted',status='old')
  READ(10) itmesh%icos_grid(1,1:nip),itmesh%icos_grid(2,1:nip),  &
             tmesh(1:ntmp)
  CLOSE(10)

! adjust the read-in tmesh data so that its vertex and adjnb orders are 
! counter-clock wise and consistent to each other.
#ifdef DIAG
  PRINT*, 'Adjust tmesh data.' 
#endif
  DO i = 1, ntmp 
    p(1:2) = itmesh%icos_grid(1:2, tmesh(i)%vertex(1))
    p1(1:2) = itmesh%icos_grid(1:2, tmesh(i)%vertex(2))
    p2(1:2) = itmesh%icos_grid(1:2, tmesh(i)%vertex(3))
    IF (righthand(p, p1, p2) .neqv. .true.) THEN
      itmp = tmesh(i)%vertex(2) 
      tmesh(i)%vertex(2) = tmesh(i)%vertex(3);
      tmesh(i)%vertex(3) = itmp
    ENDIF
  ENDDO 

  DO i = 1, ntmp 
    DO j = 1, 3
      jp1 = mod(j,3) + 1
      v1 = tmesh(i)%vertex(j)
      v2 = tmesh(i)%vertex(jp1)
      DO k = 1, 3
        IF (tmesh(tmesh(i)%adjnb(k))%vertex(1) == v2 .AND. &
            tmesh(tmesh(i)%adjnb(k))%vertex(2) == v1 ) THEN 
          adjnb(j) = tmesh(i)%adjnb(k)
          EXIT
        ENDIF
        IF (tmesh(tmesh(i)%adjnb(k))%vertex(2) == v2 .AND. &
            tmesh(tmesh(i)%adjnb(k))%vertex(3) == v1 ) THEN 
          adjnb(j) = tmesh(i)%adjnb(k)
          EXIT
        ENDIF
        IF (tmesh(tmesh(i)%adjnb(k))%vertex(3) == v2 .AND. &
            tmesh(tmesh(i)%adjnb(k))%vertex(1) == v1 ) THEN 
          adjnb(j) = tmesh(i)%adjnb(k)
          EXIT
        ENDIF
      ENDDO
    ENDDO
#ifdef DIAG
!    PRINT*, 'org',tmesh(i)%adjnb(:)
!    PRINT*, 'new', adjnb(:)
#endif
    tmesh(i)%adjnb(1:3) = adjnb(1:3)
  ENDDO 

#ifdef DIAG
  PRINT*, 'Copy adjacent neighbor and vertex info to itmesh ...'
#endif
  DO i = 1, ntmp 
    itmesh%adjnb(1:3,i) = tmesh(i)%adjnb(1:3)
    itmesh%cv_vrtx(1:3,i) = tmesh(i)%vertex(1:3)
  ENDDO

#ifdef DIAG
  PRINT*, 'Compute the index of the shared side for adjacent neighbors ...'
#endif
  DO i = 1, ntmp
    DO j = 1, 3
      nb_idx = itmesh%adjnb(j,i) 
      DO k = 1, 3
        IF (itmesh%adjnb(k,nb_idx) == i) THEN
          itmesh%adjnb_si(j,i) = k
          EXIT
        ENDIF
      ENDDO
    ENDDO
  ENDDO

  DEALLOCATE(tmesh)
     
  PRINT*, 'Start to compute geometric information for triangle grid ...'

! calculate stencil indices for all triangle cells
!         ____________       
!        /\    /\    /\
!       /+ \  /  \  /+ \
!      /____\/____\/____\
!      \    /\ i  /\    /
!       \  /  \  /  \  /
!        \/____\/____\/
!         \    /\    /
!          \  /+ \  /
!           \/____\/
! fig 1. An illustration of stencils for triagngle 'i', (+ indicates 
! the additional members for 13-point triangle stencil).
!

! first calculate triangle stencils

  PRINT*, '  Calculate stencils for each triangle;'
  DO i = 1, ntmp 
    ! add ith triangle to the stencil
    s_idx = 1
    itmesh%cv_stcl(s_idx,i) = i
    s_idx = s_idx + 1
    ! for ith triangle, add all its adj. neighbor triangles to the stencil
    DO k = 1, 3
      itmesh%cv_stcl(s_idx,i) = itmesh%adjnb(k,i) 
      s_idx = s_idx + 1
    ENDDO
    ! for ith triangle's 3 adj. neighbors, add their adj. neighbors,
    ! except for the ith triangle, to the stencil
    DO j = 2, 4
      DO k = 1, 3
        stcl_cndt = itmesh%adjnb(k,itmesh%cv_stcl(j,i)) 
        IF (stcl_cndt /= i) THEN
          itmesh%cv_stcl(s_idx,i) = stcl_cndt 
          s_idx = s_idx + 1
        ENDIF
      ENDDO
    ENDDO    
    ! if use stencil of 13 (12, when a triangle is in a pentagon) members 
    ! for the triangles added to the stencil in last iteration, add their
    ! shared adj. neighbors
    IF (stcl_sz > 10) THEN
      cndt_list = 0
      num_cndts = 0
      DO j = 5, 10
        DO k = 1, 3
          stcl_cndt = itmesh%adjnb(k,itmesh%cv_stcl(j,i)) 
          IF (not_in_cur_stcl(stcl_cndt, itmesh%cv_stcl(:,i))) THEN
            IF (match_found(stcl_cndt,cndt_list,num_cndts)) THEN
              itmesh%cv_stcl(s_idx,i) = stcl_cndt 
              s_idx =s_idx + 1
            ENDIF
          ENDIF
        ENDDO
      ENDDO    
    ENDIF
  ENDDO

#ifdef USE_EDGE_STCL
!
! calculate stencil indices each edge of triangle cells
!              ____________
!             /\    /\    /\
!            /1 \3 /5 \ 7/ 9\
!           /____\/__e_\/____\
!           \    /\    /\    /
!            \2 /4 \6 /8 \10/
!             \/____\/____\/
!
! fig 2. An illustration of stencils for edge 'e'
!
!
  PRINT*, '  Calculate stencils for each edge of all triangles;'
  
  DO i = 1, ntmp
    DO j = 1, 3
      stcl(6) = i

      jp1 = mod(j, 3) + 1
      stcl(4) = itmesh%adjnb(jp1,stcl(6))

      nb_sidx = itmesh%adjnb_si(jp1,stcl(6))
      nb_sidx_p1 = mod(nb_sidx, 3) + 1 
      stcl(2) = itmesh%adjnb(nb_sidx_p1,stcl(4)) 

      IF (edge_stcl_sz == 14) THEN
#ifndef NEW_STCL
        nb_sidx = itmesh%adjnb_si(nb_sidx_p1,stcl(4))
        nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
        stcl(12) = itmesh%adjnb(nb_sidx_m1,stcl(2)) 
#else
        nb_sidx = itmesh%adjnb_si(jp1,stcl(6))
        nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
        stcl(12) = itmesh%adjnb(nb_sidx_m1,stcl(4)) 
#endif
      ENDIF

      jm1 = mod((j-1)-3, 3) + 3
      stcl(8) = itmesh%adjnb(jm1,stcl(6))

      nb_sidx = itmesh%adjnb_si(jm1,stcl(6))
      nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
      stcl(10) = itmesh%adjnb(nb_sidx_m1,stcl(8)) 

      IF (edge_stcl_sz == 14) THEN
#ifndef NEW_STCL
        nb_sidx = itmesh%adjnb_si(nb_sidx_m1,stcl(8))
        nb_sidx_p1 = mod(nb_sidx, 3) + 1 
        stcl(14) = itmesh%adjnb(nb_sidx_p1,stcl(10)) 
#else
        nb_sidx = itmesh%adjnb_si(jm1,stcl(6))
        nb_sidx_p1 = mod(nb_sidx, 3) + 1 
        stcl(14) = itmesh%adjnb(nb_sidx_p1,stcl(8)) 
#endif
      ENDIF

!              ____________
!             /\    /\    /\
!            /1 \3 /5 \ 7/ 9\
!           /____\/__e_\/____\
!           \    /\    /\    /
!            \2 /4 \6 /8 \10/
!             \/____\/____\/

      stcl(5) = itmesh%adjnb(j,i)
          
      jp = itmesh%adjnb_si(j,i) ! the edge # in 5 for the edge j in  6

      jp_m1 = mod((jp-1)-3, 3) + 3 
      stcl(3) = itmesh%adjnb(jp_m1,stcl(5))

      nb_sidx = itmesh%adjnb_si(jp_m1,stcl(5))
      nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
      stcl(1) = itmesh%adjnb(nb_sidx_m1,stcl(3)) 

      IF (edge_stcl_sz == 14) THEN
#ifndef NEW_STCL
        nb_sidx = itmesh%adjnb_si(nb_sidx_m1,stcl(3))
        nb_sidx_p1 = mod(nb_sidx, 3) + 1 
        stcl(11) = itmesh%adjnb(nb_sidx_p1,stcl(1)) 
#else
       nb_sidx = itmesh%adjnb_si(jp_m1,stcl(5))
       nb_sidx_p1 = mod(nb_sidx, 3) + 1 
       stcl(11) = itmesh%adjnb(nb_sidx_p1,stcl(3)) 
#endif

      ENDIF

      jp_p1 = mod(jp, 3) + 1
      stcl(7) = itmesh%adjnb(jp_p1,stcl(5))

      nb_sidx = itmesh%adjnb_si(jp_p1,stcl(5))
      nb_sidx_p1 = mod(nb_sidx, 3) + 1 
      stcl(9) = itmesh%adjnb(nb_sidx_p1,stcl(7)) 

      IF (edge_stcl_sz == 14) THEN
#ifndef NEW_STCL
        nb_sidx = itmesh%adjnb_si(nb_sidx_p1,stcl(7))
        nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
        stcl(13) = itmesh%adjnb(nb_sidx_m1,stcl(9)) 
#else
        nb_sidx = itmesh%adjnb_si(jp_p1,stcl(5))
        nb_sidx_m1 = mod((nb_sidx-1)-3, 3) + 3 
        stcl(13) = itmesh%adjnb(nb_sidx_m1,stcl(7)) 
#endif
      ENDIF
      itmesh%edge_stcl(:,j,i) = stcl(1:edge_stcl_sz)
    ENDDO
  ENDDO
#endif

!#ifdef USE_VRTX_STCL

! stencil for a given triangle vertex v - VRTX_10_PTS_1
!              ____________        
!             /\    /\    /\
!            / 8\  /  \  / 7\
!           /____\/____\/____\     north-most edge: edge 1
!          /\    /\ 1  /\    /\
!         /  \  / 2\  /6 \  /  \
!        /____\/____\v____\/____\  v: at the center of the graph
!        \    /\  3 /\ 5  /\    /
!         \  /  \  /4 \  /  \  /
!          \/____\/____\/____\/
!           \  9 /\    /\ 10 /
!            \  /  \  /  \  / 
!             \/____\/____\/
!
! Figure x  first stencil choice 

! stencil for a given triangle vertex v - VRTX_10_PTS_2
!
!              ____________        
!             /\ 10 /\    /\
!            /  \gl/ 7\  /10\
!           /____\/____\/v_gl\     north-most edge: edge 1
!          /\    /\ 1  /\    /\
!         /10\  / 2\  /6 \  /  \
!        /_gl_\/____\v____\/____\  v: at the center of the graph
!        \    /\  3 /\ 5  /\ 10 /
!         \  / 8\  /4 \  / 9\gl/
!          \/____\/____\/____\/
!           \ 10 /\    /\    /
!            \gl/  \  /10\  / 
!             \/____\/_gl_\/
!
! Figure x+1 second stencile choice

! stencil for a given triangle vertex v - VRTX_HEXAGRAM
!
!                                  
!                   /\
!                  / 7\
!           _____ /____\______     north-most edge: edge 1
!           \  8 /\ 1  /\ 12 /
!            \  / 2\  /6 \  /
!             \/____\v____\/       v: at the center of the graph
!             /\  3 /\ 5  /\
!            / 9\  /4 \  /11\
!           /____\/____\/____\
!                 \ 10 /
!                  \  /
!                   \/
!
! Figure x+2 stencile choice

! compute vertex and triangle relation, insert the 1-6 triangles into the stencil 
  itmesh%num_tri = 0
  itmesh%vrtx_stcl = 0
  DO i = 1, ntmp
    DO j = 1, 3
      ipn = itmesh%cv_vrtx (j,i)  
      itmesh%num_tri(ipn) = itmesh%num_tri(ipn) + 1
      itmesh%vrtx_stcl(itmesh%num_tri(ipn),ipn) = i 
    ENDDO
  ENDDO
 
! sort and orient the 1-6 inner triangles in the stencil
  dbg_ipn = 2
  DO ipn = 1, nip
    CALL sort_orient_stcl(ipn, itmesh%vrtx_stcl(:,ipn), itmesh%num_tri, itmesh%cv_vrtx, itmesh%icos_grid, itmesh%adjnb)
  ENDDO

! add the outer triangles to the stencil
  DO ipn = 1, nip
#ifdef VRTX_10_PTS_1
    CALL add_outer_tri1(ipn, itmesh%vrtx_stcl, itmesh%num_tri, itmesh%cv_vrtx, itmesh%icos_grid, itmesh%adjnb)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, ',stcl-v:', itmesh%vrtx_stcl(1:10,ipn)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, 'stcl-gl:', itmesh%vrtx_stcl(11:16,ipn)
#endif
#ifdef VRTX_10_PTS_2
    CALL add_outer_tri2(ipn, itmesh%vrtx_stcl, itmesh%num_tri, itmesh%cv_vrtx, itmesh%icos_grid, itmesh%adjnb)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, ',stcl-v:', itmesh%vrtx_stcl(1:10,ipn)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, 'stcl-gl:', itmesh%vrtx_stcl(11:16,ipn)
#endif
#ifdef VRTX_HEXAGRAM
    CALL add_outer_tri(ipn, itmesh%vrtx_stcl, itmesh%num_tri, itmesh%cv_vrtx, itmesh%icos_grid, itmesh%adjnb)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, ',stcl-v and stcl-gl:', itmesh%vrtx_stcl(1:12,ipn)
#endif
#ifdef VRTX_LGHEXAGON
    CALL add_outer_tri3(ipn, itmesh%vrtx_stcl, itmesh%num_tri, itmesh%cv_vrtx, itmesh%icos_grid, itmesh%adjnb)
    IF (ipn == dbg_ipn) print*, 'vertex', ipn, ',stcl-v and stcl-gl (large hexagon):', itmesh%vrtx_stcl(1:24,ipn)
#endif

  ENDDO


#ifdef USE_EDGE_STCL
#ifdef NO_REP_10_PTS
  DO i = 1, ntmp
    DO j = 1, 3
      stcl(1:edge_stcl_sz) = itmesh%edge_stcl(:,j,i) 
      IF (stcl(1) == stcl(2)) THEN
        DO k = 1,3
          nb_idx = itmesh%adjnb(k, stcl(1)) 
          IF (nb_idx /= stcl(3) .AND. nb_idx /= stcl(4))  THEN
            stcl(1) = nb_idx
            jp = itmesh%adjnb_si(k,stcl(2)) 
            IF (edge_stcl_sz == 14) THEN
            jp_p1 = mod(jp, 3) + 1
            stcl(11) = itmesh%adjnb(jp_p1,stcl(1))
            jp_m1 = mod((jp-1)-3, 3) + 3 
            stcl(12) = itmesh%adjnb(jp_m1,stcl(1))
            ENDIF
            EXIT
          ENDIF
        ENDDO
      ENDIF        

      IF (stcl(10) == stcl(9)) THEN
        DO k = 1,3
          nb_idx = itmesh%adjnb(k, stcl(10)) 
          IF (nb_idx /= stcl(7) .AND. nb_idx /= stcl(8))  THEN
            stcl(10) = nb_idx
            jp = itmesh%adjnb_si(k,stcl(9)) 
            IF (edge_stcl_sz == 14) THEN
            jp_m1 = mod((jp-1)-3, 3) + 3 
            stcl(13) = itmesh%adjnb(jp_m1,stcl(10))
            jp_p1 = mod(jp, 3) + 1
            stcl(14) = itmesh%adjnb(jp_p1,stcl(10))
            ENDIF
            EXIT
          ENDIF
        ENDDO
      ENDIF        
      itmesh%edge_stcl(:,j,i) = stcl(1:edge_stcl_sz)
    ENDDO
  ENDDO
#endif
#endif
           
! calculate constrained centroid (center) for each triangle cell
  PRINT*, '  Calculate Centroid for each triangle cell;'
  DO i = 1, ntmp 
    latlon1(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(1,i)) 
    latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(2,i)) 
    latlon3(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(3,i)) 
    CALL ll2xyz(latlon1, xyz(:,1))
    CALL ll2xyz(latlon2, xyz(:,2))
    CALL ll2xyz(latlon3, xyz(:,3))
    cntr_xyz = 1.0/3.0*(xyz(:,1) + xyz(:,2) + xyz(:,3))
    CALL normalize(cntr_xyz)
    CAll xyz2ll(cntr_xyz, cntr_ll)
    itmesh%center(:,i) = cntr_ll(:)
  ENDDO
! calculate tangential and normal vectors for edges of each triangle 
  DO i = 1, ntmp 
    DO j = 1, 3
      jp1 = mod(j,3) + 1
      t_vec(:,j) = xyz(:,jp1) - xyz(:,j)
      CALL normalize(t_vec(:,j))
      CALL cross_product(n_vec(:,j), xyz(:,jp1), xyz(:,j))
      CALL normalize(n_vec(:,j))
    ENDDO
! convert 3d normal and tangent vectors to 2d vectors the plane tangential at 
! mid of the edge, with x-y axes in positive latitude and longitude direction.
    DO j = 1, 3
      jp1 = mod(j,3) + 1
      latlon1(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(j,i)) 
      latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,i)) 
      CALL middle(latlon1, latlon2, mp)
      CALL ll2xyz(mp,xyz(:,1))
      IF (mp(1) + latdt < piov2) THEN
        mp(1) = mp(1) + latdt
        CALL ll2xyz(mp,xyz(:,2))
        CALL cross_product(x_axis, xyz(:,2), xyz(:,1))   
      ELSE 
        mp(1) = mp(1) - latdt
        CALL ll2xyz(mp,xyz(:,2))
        CALL cross_product(x_axis, xyz(:,1), xyz(:,2))   
      ENDIF
      CALL normalize(x_axis)
      CALL cross_product(y_axis, xyz(:,1), x_axis) 
      CALL normalize(y_axis)

      t_vec2d(1) = dot_product(t_vec(:,j), x_axis) 
      t_vec2d(2) = dot_product(t_vec(:,j), y_axis) 
      n_vec2d(1) = dot_product(n_vec(:,j), x_axis) 
      n_vec2d(2) = dot_product(n_vec(:,j), y_axis) 
    ENDDO

    itmesh%t_vec(:,:,i) = t_vec(:,:)      
    itmesh%n_vec(:,:,i) = n_vec(:,:)      
  ENDDO

! calculate side lengths and area of each triangle cell
  PRINT*, '  Calculate area for each triangle cell;'
#ifdef SPH_GEO
  DO i = 1, ntmp 
    DO j = 1, 3
      jp1 = mod(j,3) + 1
      latlon1(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(j,i)) 
      latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,i)) 
      side(j) = gcdist(latlon1, latlon2)
      itmesh%lnth(j,i) = earth_radius * side(j)
    ENDDO
    a = side(1); b = side(2); c = side(3)
    s = 0.5D0 * (a + b + c)
    tanEov4 = sqrt(tan(0.5D0*s)*tan(0.5D0*(s-a))*tan(0.5D0*(s-b))*tan(0.5D0*(s-c)))
    itmesh%area(i) = atan(tanEov4) * 4.0D0 * earth_radius * earth_radius
  ENDDO
#else
  DO i = 1, ntmp 
    DO j = 1, 3
      jp1 = mod(j,3) + 1
      latlon1(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(j,i)) 
      latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,i)) 
      side(j) = ecdist(latlon1, latlon2)
      itmesh%lnth(j,i) = earth_radius * side(j)
    ENDDO
    a = side(1); b = side(2); c = side(3)
    s = 0.5 * (a + b + c)
    itmesh%area(i) = sqrt(s*(s-a)*(s-b)*(s-c))*earth_radius*earth_radius
  ENDDO
#endif

!return
#ifdef USE_EDGE_STCL
! calculate side coeff of each triangle cell
  PRINT*, '  Calculate side coeff for each triangle cell...'
  DO i = 1, ntmp 
    DO j = 1, 3
!print*, ' <><><><>', i, j
      jp1 = mod(j,3) + 1
      latlon1(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(j,i)) 
      latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,i)) 
#ifdef MID_EDGE
      CALL middle(latlon1, latlon2, mp)
#else 
      r1 = 0.5 - 1.0 / sqrt(3.0) / 2.0
      r2 = 0.5 + 1.0 / sqrt(3.0) / 2.0
      CALL pt_at_r(latlon1, latlon2, qp1, r1)
      CALL pt_at_r(latlon1, latlon2, qp2, r2)
      r3 = 1.0 - 1.0 / sqrt(3.0)
      r4 = 1.0 / sqrt(3.0)
      CALL pt_at_r(latlon1, latlon2, qp3, r3)
      CALL pt_at_r(latlon1, latlon2, qp4, r4)
#endif
      stcl(1:edge_stcl_sz) = itmesh%edge_stcl(:,j,i)  
      dbg_prt = dbg_idx_match(i,j,ij_debug,ndbp)

#ifdef MID_EDGE 
#ifndef EULER_ROT
      DO k = 1, edge_stcl_sz
        ll(:,k) = itmesh%center(:, stcl(k))
        CALL ll2xy(mp(2), mp(1), ll(2,k), ll(1,k), xy_1_ssz(1,k), xy_1_ssz(2,k)) 
      ENDDO
#else
      DO k = 1, edge_stcl_sz
        ll(:,k) = itmesh%center(:, stcl(k))
      ENDDO
      edge(:,1) = latlon1(:); edge(:,2) = latlon2(:)
      CALL eulerRotate1(edge, ll, xy_1_ssz, edge_stcl_sz, dbg_prt)
#endif
      IF (dbg_prt) then
        PRINT*, 'midedge: i, edge, and glvl = ',i, j, glvl
        PRINT*, 'edge vertex indices = ',itmesh%cv_vrtx(j,i), itmesh%cv_vrtx(jp1,i)
        PRINT*, 'mp= ', mp
        PRINT*, 'edge_stcl= ', itmesh%edge_stcl(:,j,i)
        PRINT*, 'vrtx_stcl= ', itmesh%vrtx_stcl(:,j,i)
      
        DO k = 1, edge_stcl_sz
          PRINT*, k, 'll(:,k)', ll(:,k)*r2d
        ENDDO
        DO k = 1, edge_stcl_sz
          PRINT*, k, 'xy_1_ssz(:,k)', xy_1_ssz(:,k)
        ENDDO
      ENDIF
      CALL comp_intp_coef_mid_edge(itmesh, i, j, stcl, latlon1, latlon2, mp, xy_1_ssz, dbg_prt, glvl)
#else
#ifndef EULER_ROT
      DO k = 1, edge_stcl_sz
        ll(:,k) = itmesh%center(:, stcl(k))
        CALL ll2xy(qp1(2), qp1(1), ll(2,k), ll(1,k), xy1_1_ssz(1,k), xy1_1_ssz(2,k)) 
      ENDDO
      DO k = 1, edge_stcl_sz
        ll(:,k) = itmesh%center(:, stcl(k))
        CALL ll2xy(qp2(2), qp2(1), ll(2,k), ll(1,k), xy2_1_ssz(1,k), xy2_1_ssz(2,k)) 
      ENDDO
#else
      DO k = 1, edge_stcl_sz
        ll(:,k) = itmesh%center(:, stcl(k))
      ENDDO
      edge(:,1) = latlon1(:); edge(:,2) = qp3(:)
      CALL eulerRotate1(edge, ll, xy1_1_ssz, edge_stcl_sz, dbg_prt)
      edge(:,1) = qp4(:); edge(:,2) = latlon2(:)
      CALL eulerRotate1(edge, ll, xy2_1_ssz, edge_stcl_sz, dbg_prt)
#endif
      IF (dbg_prt) then
        PRINT*, 'G-L i, edge, and glvl = ',i, j, glvl
        PRINT*, 'edge vertex indices = ',itmesh%cv_vrtx(j,i), itmesh%cv_vrtx(jp1,i)
        PRINT*, 'mp= ', mp
        PRINT*, 'edge_stcl= ', itmesh%edge_stcl(:,j,i)
      
        DO k = 1, edge_stcl_sz
          PRINT*, k, 'll(:,k)', ll(:,k)*r2d
        ENDDO
        DO k = 1, edge_stcl_sz
          PRINT*, k, 'xy1_1_ssz(:,k)', xy1_1_ssz(:,k)
        ENDDO
        DO k = 1, edge_stcl_sz
          PRINT*, k, 'xy2_1_ssz(:,k)', xy2_1_ssz(:,k)
        ENDDO
      ENDIF
      CALL comp_intp_coef_gqp(itmesh, i, j, stcl, xy1_1_ssz, xy2_1_ssz, dbg_prt, glvl)
      IF (dbg_prt) then
        PRINT*, 'Coeff at i,j', i,j, 'and glvl', glvl
        !PRINT*, itmesh%itpl_cf_nd(1:edge_stcl_sz,1,j,i)
        !PRINT*, itmesh%itpl_cf_nd(1:edge_stcl_sz,2,j,i)
            write(*,2) itmesh%itpl_cf_nd(1:edge_stcl_sz,1,j,i)
        2   format('Coeff q1: ',7D12.4)
            write(*,4) itmesh%itpl_cf_nd(1:edge_stcl_sz,2,j,i)
        4   format('Coeff q2: ',7D12.4)
        PRINT*, 'stcl at i,j', i,j, 'and glvl', glvl
        PRINT*, itmesh%edge_stcl(:,j,i) 
      ENDIF 
#endif
    ENDDO
  ENDDO
#endif

! compute interpolation coeffs for all vertices and their neighboring GL quadrature points
!          \    /
!           2  1
!       __3__\v__6__ 
!            /\
!           4  5
!          /    \

  DO ipn = 1, nip
    tri_num = itmesh%num_tri(ipn)
#ifdef VRTX_10_PTS_1
    vrtx_stcl_sz = 10
#endif
#ifdef VRTX_10_PTS_2
    vrtx_stcl_sz = 10
#endif
#ifdef VRTX_HEXAGRAM
    IF (tri_num == 6) THEN
      vrtx_stcl_sz = 12
    ELSE
      vrtx_stcl_sz = 12
    ENDIF
#endif
#ifdef VRTX_LGHEXAGON
    IF (tri_num == 6) THEN
      vrtx_stcl_sz = 24
    ELSE
      vrtx_stcl_sz = 20
    ENDIF
#endif

    stcl(1:vrtx_stcl_sz) = itmesh%vrtx_stcl(1:vrtx_stcl_sz,ipn)
! calculate interpolation coeffs for 'v'
    latlon1(:) = itmesh%icos_grid(:, ipn) 
    tri = itmesh%vrtx_stcl(1, ipn)
    DO j = 1, 3
      IF (itmesh%cv_vrtx(j,tri) == ipn) THEN
        jp1 = mod(j,3) + 1 
        latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,tri)) 
        EXIT
      ENDIF
    ENDDO
    r1 = 0.5 - 0.5 / sqrt(3.0)
    CALL pt_at_r(latlon1, latlon2, qp2, r1)
    CALL sym_ext(qp1, qp2, latlon1) 

    DO k = 1, vrtx_stcl_sz
      ll(:,k) = itmesh%center(:, itmesh%vrtx_stcl(k,ipn))
    ENDDO

    edge(:,1) = qp1(:); edge(:,2) = qp2(:)
    if (ipn == dbg_ipn) print*, 'vrtx_stcl, before cal v intp coeff:', stcl
    CALL eulerRotate1(edge, ll, xy1_1_ssz, vrtx_stcl_sz, dbg_prt)
    CALL comp_intp_coef (itmesh, ipn, tri_num+1, stcl, vrtx_stcl_sz, xy1_1_ssz, dbg_prt, glvl)

    ! Write out the vertex latlon for Jacobian test:
    if (glvl .EQ. 5) WRITE(333,*) ipn,tri_num,latlon1(:),nip

! calculate interpolation coeffs for 'GL points'
    DO i = 1, tri_num 
      tri = itmesh%vrtx_stcl(i, ipn)
#ifdef VRTX_10_PTS_2
      IF (tri_num == 6) THEN ! for VRTX_10_PTS_2, each GL pt has a different stcl 
        ll(:,10) = itmesh%center(:, itmesh%vrtx_stcl(i+10,ipn))
      ENDIF
      stcl(10) = itmesh%vrtx_stcl(i+10,ipn)
#endif
      DO j = 1, 3
        IF (itmesh%cv_vrtx(j,tri) == ipn) THEN
          jp1 = mod(j,3) + 1 
          latlon2(:) = itmesh%icos_grid(:, itmesh%cv_vrtx(jp1,tri)) 
          EXIT
        ENDIF
      ENDDO
      r3 = 1.0 - 1.0 / sqrt(3.0)  ! Ning chosed r3 (1.0-1.0/sqrt(3)) so that the GL point will be at the center of latlon1 and qp3
      CALL pt_at_r(latlon1, latlon2, qp3, r3)
      edge(:,1) = latlon1(:); edge(:,2) = qp3(:)
      if (ipn == dbg_ipn) print*, 'vrtx_stcl, before cal GL intp coeff:', stcl
! compute interpolation coefficients
      CALL eulerRotate1(edge, ll, xy1_1_ssz, vrtx_stcl_sz, dbg_prt)
      CALL comp_intp_coef (itmesh, ipn, i, stcl, vrtx_stcl_sz, xy1_1_ssz, dbg_prt, glvl)

      ! Write out GL latlon for Jacobian testing:
      r3 = 0.5D0*(1.0D0-DSQRT(3.0D0))
      CALL pt_at_r(latlon1, latlon2, qp3, r3)
      if (glvl .EQ. 5) write(333,*) i,qp3
    ENDDO
  ENDDO

! create the indexes pointing to the precomputed interp coeffs and interp values. 
  dbg_tri = 797
  DO i = 1, ntmp
    DO j = 1, 3
      v1 = itmesh%cv_vrtx(j,i)
      tri_num = itmesh%num_tri(v1)
      itmesh%edge_itpl_idx(1,1,j,i) = v1 
      itmesh%edge_itpl_idx(2,1,j,i) = tri_num+1 
      DO k = 1, tri_num
        IF (i == itmesh%vrtx_stcl(k,v1)) THEN
          itmesh%edge_itpl_idx(1,2,j,i) = v1 
          itmesh%edge_itpl_idx(2,2,j,i) = k 
          EXIT
        ENDIF
      ENDDO
      jp1 = mod(j,3) + 1 
      v2 = itmesh%cv_vrtx(jp1,i)
      tri_num = itmesh%num_tri(v2)
      itmesh%edge_itpl_idx(1,4,j,i) = v2 
      itmesh%edge_itpl_idx(2,4,j,i) = tri_num+1 
      DO k = 1, tri_num
        IF (i == itmesh%vrtx_stcl(k,v2)) THEN
          itmesh%edge_itpl_idx(1,3,j,i) = v2 
          kp1 = mod(k,tri_num) + 1
          itmesh%edge_itpl_idx(2,3,j,i) = kp1 
          EXIT
        ENDIF
      ENDDO
    ENDDO
    IF (dbg_tri == i) THEN
      PRINT*, 'edge index for triangle', i
      DO j = 1,3
        PRINT*, 'icos idx for tri-side',j,itmesh%edge_itpl_idx(1,:,j,i)
        PRINT*, 'edge idx for tri-side',j,itmesh%edge_itpl_idx(2,:,j,i)
      ENDDO
    ENDIF
  ENDDO  

#ifdef DIAG
  earth_area = 0.0D0 ! Yuanfu initializes this variable
  DO i = 1, ntmp 
     earth_area = earth_area + itmesh%area(i)
  ENDDO
  PRINT*, 'Earth area =', earth_area, ' (in square meters)'
#endif

! write calculated grid information to file 

#ifdef WRITE_OUTPUT
  icos_tri_grid_pc_file = "icos_tri_grid_pc_g" // gls //  ".dat"
  PRINT*, 'write ', trim(icos_tri_grid_pc_file)
  OPEN(10,file=icos_tri_grid_pc_file,form='unformatted')
  WRITE(10) itmesh%icos_grid
  WRITE(10) itmesh%area,itmesh%center 
  WRITE(10) itmesh%cv_stcl,itmesh%cv_vrtx 
  WRITE(10) itmesh%adjnb,itmesh%adjnb_si 
  WRITE(10) itmesh%lnth,itmesh%nb 
  WRITE(10) itmesh%edge_stcl,itmesh%edge_vrtx 
  WRITE(10) itmesh%vrtx_stcl
  WRITE(10) itmesh%t_vec,itmesh%n_vec 
  WRITE(10) itmesh%itpl_cf_nd,itmesh%itpl_cf_td 
  WRITE(10) itmesh%itpl_cf_fv 
  WRITE(10) itmesh%itpl_v_cf_fv 
  CLOSE(10)
#endif

  PRINT*, 'Done for precal G level', glvl
  PRINT*, ' '

END SUBROUTINE precal_itmesh

SUBROUTINE  sort_orient_stcl(ipn, stcl, num_tri, cv_vrtx, icos_grid, adjnb)
  IMPLICIT NONE   

  INTEGER, INTENT(IN) :: ipn, num_tri(:), cv_vrtx(:,:), adjnb(:,:)
  REAL*8, INTENT(IN) :: icos_grid(:,:)
  INTEGER, INTENT(OUT) :: stcl(:)

  INTEGER :: i, j, k, nm_i, nm_i2, tri, nm_tri, nm_tri2, cur_i, cur_tri
  INTEGER :: stcl_tmp(24)
  REAL*8 :: ll(2,2), mp(2,6), mp_nm(2), mp_nm2(2), md_lat, md_lat2
  REAL*8, PARAMETER :: piov2 = acos(-1.0) / 2.0, r2d = 180.0 / acos(-1.0) 
  REAL*8, PARAMETER :: eps = 0.00000001
  REAL :: p(2), p1(2), p2(2)


  LOGICAL :: righthand

  stcl_tmp = 0

! first, find the northmost triangle
  md_lat = -piov2
  md_lat2 = -piov2
  nm_tri2 = 0
  DO i = 1, num_tri(ipn)
    tri = stcl(i)
    k = 1
    DO j = 1, 3
      IF (cv_vrtx(j,tri) /= ipn) THEN 
        ll(:,k) = icos_grid(:,cv_vrtx(j,tri))
        k = k + 1
      ENDIF
    ENDDO
    CALL middle(ll(:,1), ll(:,2), mp(:,i))
    IF (mp(1,i) > md_lat) THEN 
      IF (md_lat > md_lat2) THEN
        md_lat2 = md_lat; nm_tri2 = nm_tri; mp_nm2 = mp_nm; nm_i2 = nm_i
      ENDIF
      md_lat = mp(1,i); nm_tri = tri; mp_nm = mp(:,i); nm_i = i
    ELSE IF (mp(1,i) > md_lat2) THEN
      md_lat2 = mp(1,i); nm_tri2 = tri; mp_nm2 = mp(:,i); nm_i2 = i
    ENDIF
  ENDDO
  IF (abs(md_lat - md_lat2) < eps ) THEN
    p(:) = icos_grid(:, ipn); p1(:) = mp_nm(:); p2(:) = mp_nm2(:)
    IF (righthand(p, p1, p2) .eqv. .true.) THEN
      stcl_tmp(1) = nm_tri; cur_i = nm_i
    ELSE
      stcl_tmp(1) = nm_tri2; cur_i = nm_i2
    ENDIF
  ELSE 
    stcl_tmp(1) = nm_tri; cur_i = nm_i
  ENDIF
  DO i = 1, num_tri(ipn)
    IF (stcl_tmp(1) == stcl(i)) THEN
       stcl(i) = 0
    ENDIF
  ENDDO
! second, find the correctly ordered and oriented new stencil
  DO i = 1, num_tri(ipn) - 1  
    cur_tri = stcl_tmp(i)
    DO j = 1, num_tri(ipn)
      IF (adjnb(1,cur_tri) == stcl(j) .OR. &
          adjnb(2,cur_tri) == stcl(j) .OR. &
          adjnb(3,cur_tri) == stcl(j) ) THEN
        p(:) = icos_grid(:, ipn); p1(:) = mp(:,cur_i); p2(:) = mp(:, j)
        IF (righthand(p, p1, p2)  .eqv. .true.) THEN
           stcl_tmp(i+1) = stcl(j); cur_i = j
           stcl(j) = 0
           EXIT
        ENDIF
      ENDIF
    ENDDO
  ENDDO
  stcl = stcl_tmp

END SUBROUTINE sort_orient_stcl

! stencil for a given triangle vertex v
!
!                                  
!                   /\
!                  / 7\
!           _____ /____\______     north-most edge: edge 1
!           \  8 /\ 1  /\ 12 /
!            \  / 2\  /6 \  /
!             \/____\v____\/       v: at the center of the graph
!             /\  3 /\ 5  /\
!            / 9\  /4 \  /11\
!           /____\/____\/____\
!                 \ 10 /
!                  \  /
!                   \/
!
! Figure x+2 stencile choice

SUBROUTINE  add_outer_tri(ipn, stcls, num_tri, cv_vrtx, icos_grid, adjnb)
  IMPLICIT NONE   

  INTEGER, INTENT(IN) :: ipn, num_tri(:), cv_vrtx(:,:), adjnb(:,:)
  REAL*8, INTENT(IN) :: icos_grid(:,:)
  INTEGER, INTENT(INOUT) :: stcls(:,:)

  INTEGER :: i, j, k, ip1, im1
  INTEGER :: outer_tri_idx, n_tri

  INTEGER :: tris(6)

  n_tri = num_tri(ipn)
  outer_tri_idx = num_tri(ipn) + 1

  DO i = 1, num_tri(ipn)
    tris(i) = stcls(i,ipn)
  ENDDO

  DO i = 1, num_tri(ipn)
    ip1 = mod(i,n_tri) + 1; im1 = mod((i-1)-n_tri, n_tri) + n_tri
    DO j = 1, 3
      IF (adjnb(j, tris(i)) /= tris(im1) .AND. adjnb(j, tris(i)) /= tris(ip1)) THEN
        stcls(outer_tri_idx,ipn) = adjnb(j,tris(i))
        outer_tri_idx = outer_tri_idx + 1
        EXIT
      ENDIF
    ENDDO
  ENDDO

END SUBROUTINE add_outer_tri

SUBROUTINE  add_outer_tri1(ipn, stcls, num_tri, cv_vrtx, icos_grid, adjnb)
  IMPLICIT NONE   

  INTEGER, INTENT(IN) :: ipn, num_tri(:), cv_vrtx(:,:), adjnb(:,:)
  REAL*8, INTENT(IN) :: icos_grid(:,:)
  INTEGER, INTENT(INOUT) :: stcls(:,:)

  INTEGER :: i, j, k, tri1, tri2, tri4, jp1, jm1, ip3, vrtx1, vrtx2, vrtx3, vrtx4 
  INTEGER :: tri, jp2, vrtx
  INTEGER :: outer_tri_idx

  IF (num_tri(ipn) == 6) THEN
    tri1 = stcls(1,ipn)
    DO j = 1, 3
      IF (cv_vrtx(j,tri1) == ipn) THEN
        jp1 = mod(j,3) + 1; jm1 = mod((j-1)-3, 3) + 3
        vrtx1 = cv_vrtx(jp1, tri1)
        vrtx2 = cv_vrtx(jm1, tri1)
        EXIT
      ENDIF
    ENDDO
  
    outer_tri_idx = num_tri(ipn) + 1
    DO i = 1, num_tri(vrtx1)
      IF (stcls(i,vrtx1) == tri1) THEN
        ip3 = mod(i+2, num_tri(vrtx1)) + 1 
        stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx1)
        EXIT 
      ENDIF
    ENDDO

    outer_tri_idx = outer_tri_idx + 1
    DO i = 1, num_tri(vrtx2)
      IF (stcls(i,vrtx2) == tri1) THEN
        ip3 = mod(i+2, num_tri(vrtx2)) + 1 
        stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx2)
        EXIT 
      ENDIF
    ENDDO
    tri4 = stcls(4,ipn)
    DO j = 1, 3
      IF (cv_vrtx(j,tri4) == ipn) THEN
        jp1 = mod(j,3) + 1; jm1 = mod((j-1)-3, 3) + 3
        vrtx3 = cv_vrtx(jp1, tri4)
        vrtx4 = cv_vrtx(jm1, tri4)
        EXIT
      ENDIF
    ENDDO

    outer_tri_idx = outer_tri_idx + 1
    DO i = 1, num_tri(vrtx3)
      IF (stcls(i,vrtx3) == tri4) THEN
        ip3 = mod(i+2, num_tri(vrtx3)) + 1 
        stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx3)
        EXIT 
      ENDIF
    ENDDO

    outer_tri_idx = outer_tri_idx + 1
    DO i = 1, num_tri(vrtx4)
      IF (stcls(i,vrtx4) == tri4) THEN
        ip3 = mod(i+2, num_tri(vrtx4)) + 1 
        stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx4)
        EXIT 
      ENDIF
    ENDDO

  ELSE IF (num_tri(ipn) == 5) THEN
    outer_tri_idx = num_tri(ipn) + 1
    DO i = 1, num_tri(ipn)
      tri = stcls(i,ipn)
      DO j = 1, 3
        IF (cv_vrtx(j,tri) == ipn) THEN
          jm1 = mod((j-1)-3, 3) + 3
          vrtx = cv_vrtx(jm1, tri)
          EXIT
        ENDIF
      ENDDO
  
      DO j = 1, num_tri(vrtx)
        IF (stcls(j,vrtx) == tri) THEN
          jp2 = mod(j+1, num_tri(vrtx)) + 1 
          stcls(outer_tri_idx,ipn) = stcls(jp2,vrtx)
          EXIT 
        ENDIF
      ENDDO
      outer_tri_idx = outer_tri_idx + 1
    ENDDO
  ENDIF
END SUBROUTINE add_outer_tri1

! stencil for a given triangle vertex v
!
!              ____________        
!             /\ 10 /\    /\
!            /  \gl/ 7\  /10\
!           /____\/____\/v_gl\     north-most edge: edge 1
!          /\    /\ 1  /\    /\
!         /10\  / 2\  /6 \  /  \
!        /_gl_\/____\v____\/____\  v: at the center of the graph
!        \    /\  3 /\ 5  /\ 10 /
!         \  / 8\  /4 \  / 9\gl/
!          \/____\/____\/____\/
!           \ 10 /\    /\    /
!            \gl/  \  /10\  / 
!             \/____\/_gl_\/
!
! Figure x+1 second stencile choice

SUBROUTINE add_outer_tri2(ipn, stcls, num_tri, cv_vrtx, icos_grid, adjnb)
  IMPLICIT NONE   

  INTEGER, INTENT(IN) :: ipn, num_tri(:), cv_vrtx(:,:), adjnb(:,:)
  REAL*8, INTENT(IN) :: icos_grid(:,:)
  INTEGER, INTENT(INOUT) :: stcls(:,:)

  INTEGER :: i, j, k, i2, tris(6)
  INTEGER :: jp1, jp3, jm1, ip1, im1, ip3, vrtx1, vrtx2, vrtx3, vrtx4 
  INTEGER :: tri, jp2, vrtx
  INTEGER :: outer_tri_idx

  outer_tri_idx = num_tri(ipn) + 1
  IF (num_tri(ipn) == 6) THEN
    DO k = 1, 6
      tris(k) = stcls(k,ipn)
    ENDDO
    
! add three adjacent neighbors of the 'inner triangles' 1, 3, and 5, as the 7, 8, and 9
! stencil points
    DO i = 1, 5, 2
      ip1 = mod(i,6) + 1; im1 = mod((i-1)-6, 6) + 6
      DO j = 1, 3
        IF (adjnb(j, tris(i)) /= tris(im1) .AND. adjnb(j, tris(i)) /= tris(ip1)) THEN
          stcls(outer_tri_idx,ipn) = adjnb(j,tris(i))
          outer_tri_idx = outer_tri_idx + 1
          EXIT
        ENDIF
      ENDDO
    ENDDO
        
! add the 10th triangle for the ipn vertex 
    DO j = 1, 3
      IF (cv_vrtx(j,tris(1)) == ipn) THEN
        jp1 = mod(j,3) + 1; jm1 = mod((j-1)-3, 3) + 3
        vrtx1 = cv_vrtx(jp1, tris(1))
        EXIT
      ENDIF
    ENDDO
        
    DO i = 1, num_tri(vrtx1)
      IF (stcls(i,vrtx1) == tris(1)) THEN
        ip3 = mod(i+2, num_tri(vrtx1)) + 1 
        stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx1)
        outer_tri_idx = outer_tri_idx + 1
        EXIT 
      ENDIF
    ENDDO
          
! add the 10th triangle for 6 GL points
    DO i = 1, 6
      DO j = 1, 3
        IF (cv_vrtx(j,tris(i)) == ipn) THEN
          jp1 = mod(j,3) + 1; jm1 = mod((j-1)-3, 3) + 3
          vrtx1 = cv_vrtx(jp1, tris(i))
          EXIT
        ENDIF
      ENDDO
    
      DO i2 = 1, num_tri(vrtx1)
        IF (stcls(i2,vrtx1) == tris(i)) THEN
          ip3 = mod(i2+2, num_tri(vrtx1)) + 1 
          stcls(outer_tri_idx,ipn) = stcls(ip3,vrtx1)
          outer_tri_idx = outer_tri_idx + 1
          EXIT 
        ENDIF
      ENDDO
    ENDDO
  ELSE IF (num_tri(ipn) == 5) THEN  ! pentagon vertex
    DO i = 1, num_tri(ipn)
#ifndef SHARE_EDGE
      tri = stcls(i,ipn)
      DO j = 1, 3
        IF (cv_vrtx(j,tri) == ipn) THEN
          jp1 = mod(j, 3) + 1
          vrtx = cv_vrtx(jp1, tri)
          EXIT
        ENDIF
      ENDDO
      DO j = 1, num_tri(vrtx)
        IF (stcls(j,vrtx) == tri) THEN
          jp3 = mod(j+2, num_tri(vrtx)) + 1 
          stcls(outer_tri_idx,ipn) = stcls(jp3,vrtx)
          EXIT 
        ENDIF
      ENDDO
#else
      tri = stcls(i,ipn)
      ip1 = mod(i,5) + 1; im1 = mod((i-1)-5, 5) + 5
      DO j = 1, 3
        IF (adjnb(j, tri) /= stcls(im1,ipn) .AND.  & 
            adjnb(j, tri) /= stcls(ip1,ipn)) THEN
          stcls(outer_tri_idx,ipn) = adjnb(j,tri)
          outer_tri_idx = outer_tri_idx + 1
          EXIT
        ENDIF
      ENDDO
#endif
    ENDDO
  ENDIF
END SUBROUTINE add_outer_tri2

! stencil for a given triangle vertex v
!
!              ____________         
!             /\ 14 /\ 13 /\
!            /15\  / 7\  /24\
!           /____\/____\/____\     north-most edge: edge 1
!          /\  8 /\ 1  /\ 12 /\
!         /16\  / 2\  /6 \  /23\
!        /____\/____\v____\/____\   v: at the center of the graph
!        \ 17 /\  3 /\ 5  /\ 22 /
!         \  / 9\  /4 \  /11\  /
!          \/____\/____\/____\/
!           \ 18 /\ 10 /\ 21 /
!            \  /19\  /20\  /
!             \/____\/____\/
!
! Figure x+3 stencile choice

SUBROUTINE  add_outer_tri3(ipn, stcls, num_tri, cv_vrtx, icos_grid, adjnb)
  IMPLICIT NONE   

  INTEGER, INTENT(IN) :: ipn, num_tri(:), cv_vrtx(:,:), adjnb(:,:)
  REAL*8, INTENT(IN) :: icos_grid(:,:)
  INTEGER, INTENT(INOUT) :: stcls(:,:)

  INTEGER :: i, j, k, ip1, im1, jp1, jm1
  INTEGER :: outer_tri_idx, n_tri

  INTEGER :: tris(6)

  n_tri = num_tri(ipn)
  outer_tri_idx = num_tri(ipn) + 1

  DO i = 1, num_tri(ipn)
    tris(i) = stcls(i,ipn)
  ENDDO

  DO i = 1, num_tri(ipn)
    ip1 = mod(i,n_tri) + 1; im1 = mod((i-1)-n_tri, n_tri) + n_tri
    DO j = 1, 3
      IF (adjnb(j, tris(i)) /= tris(im1) .AND. adjnb(j, tris(i)) /= tris(ip1)) THEN
        stcls(outer_tri_idx,ipn) = adjnb(j,tris(i))
        outer_tri_idx = outer_tri_idx + 1
        EXIT
      ENDIF
    ENDDO
  ENDDO

!  IF  (n_tri == 5) RETURN  ! leave 10 stencil for pentagon vertex.

  DO i = 1, n_tri
    DO j = 1, 3
      jp1 = mod(j,3) + 1; jm1 = mod((j-1)-3,3) + 3
      IF (adjnb(j, stcls(i+n_tri,ipn)) == tris(i)) THEN
        stcls(outer_tri_idx,ipn) = adjnb(jp1,stcls(i+n_tri,ipn))
        outer_tri_idx = outer_tri_idx + 1
        stcls(outer_tri_idx,ipn) = adjnb(jm1,stcls(i+n_tri,ipn))
        outer_tri_idx = outer_tri_idx + 1
        EXIT
      ENDIF
    ENDDO
  ENDDO

END SUBROUTINE add_outer_tri3

! earth distance between two points defined in lat/lon radius
REAL*8 FUNCTION gcdist_e(ltln1,ltln2)
    IMPLICIT NONE
    
    REAL*8 :: ltln1(2), ltln2(2)
!    REAL*8 :: gcdist
    REAL*8, PARAMETER :: e_radius = 6371.220

    gcdist_e = e_radius*gcdist(ltln1, ltln2)    

    RETURN 

END FUNCTION gcdist_e 
 
REAL*8 FUNCTION gcdist(ltln1,ltln2)
    IMPLICIT NONE

    REAL*8 :: ltln1(2), ltln2(2)
    REAL*8 :: dlatov2, dlonov2, a
    
    dlatov2 = (ltln2(1) - ltln1(1)) * 0.5D0
    dlonov2 = (ltln2(2) - ltln1(2)) * 0.5D0

    a = sin(dlatov2) * sin(dlatov2) + cos(ltln1(1))*cos(ltln2(1))*sin(dlonov2)*sin(dlonov2)
    gcdist = 2.0D0 * atan2(sqrt(a), sqrt(1.0D0-a))

END FUNCTION gcdist

REAL*8 FUNCTION ecdist(ltln1,ltln2)
    IMPLICIT NONE

    REAL*8 :: ltln1(2), ltln2(2)
    
    REAL*8 :: xyz1(3), xyz2(3)

    CALL ll2xyz(ltln1, xyz1)
    CALL ll2xyz(ltln2, xyz2)

    ecdist = sqrt((xyz2(1) - xyz1(1)) * (xyz2(1) - xyz1(1)) + &
                  (xyz2(2) - xyz1(2)) * (xyz2(2) - xyz1(2)) + &
                  (xyz2(3) - xyz1(3)) * (xyz2(3) - xyz1(3))) 

END FUNCTION ecdist

LOGICAL FUNCTION not_in_cur_stcl(cndt, stcls)
    IMPLICIT NONE

    INTEGER :: cndt, stcls(10)

    INTEGER :: i

    DO i = 1, 10
      IF (cndt == stcls(i)) THEN
        not_in_cur_stcl = .FALSE.
        RETURN
      ENDIF
    ENDDO
      
    not_in_cur_stcl = .TRUE.

END FUNCTION not_in_cur_stcl

LOGICAL FUNCTION match_found(cndt, cndt_list, num_cndts) 
    IMPLICIT NONE

    INTEGER :: cndt, cndt_list(10), num_cndts

    INTEGER :: i

    DO i = 1, num_cndts
      IF (cndt == cndt_list(i)) THEN
        match_found = .TRUE.
        RETURN
      ENDIF
    ENDDO
    num_cndts = num_cndts + 1
    cndt_list(num_cndts) = cndt
    match_found = .FALSE.

END FUNCTION match_found


LOGICAL FUNCTION dbg_idx_match(i_idx,j_idx,dbg_idx, n)
    IMPLICIT NONE
    
    INTEGER, INTENT(IN) :: n
    INTEGER, INTENT(IN) :: i_idx,j_idx, dbg_idx(2,n) 

    INTEGER :: i

    dbg_idx_match = .FALSE.
    DO i = 1, n
      IF (i_idx == dbg_idx(1,i)) THEN
        IF (j_idx == dbg_idx(2,i)) THEN
          dbg_idx_match = .TRUE.
          EXIT
        ENDIF
      ENDIF
    ENDDO

END FUNCTION dbg_idx_match
END MODULE precal
